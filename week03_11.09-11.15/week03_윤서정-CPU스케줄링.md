# CPU Scheduling

## 1. 정의

: 여러 프로세스가 CPU를 사용하기 위해 경쟁할 때 어떤 프로세스가 CPU를 할당받을지를 결정하는 작업.
운영체제는 CPU 스케줄링 알고리즘을 통해 프로세스를 효율적으로 관리하고, 시스템의 성능을 최적화하기 위해 다양한 방식으로 CPU를 할당함.

- 목표 : 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓

\*_기아현상(Starvation): 낮은 우선순위를 가진 프로세스가 계속해서 CPU 자원을 할당받지 못하고 오래 대기해야 하는 현상_

- 시스템 환경 유형
  1. **Batch System**: (일괄처리 시스템) 가능하면 많은 일을 수행하는 것이 주목적. 처리량(throughout) 중시.<br>
     // 대규모 데이터 처리, 과학 및 공학 계산, 대량의 업무 처리 등
  2. **Interactive System**: (대화형 시스템) 사용자 경험 중시. 빠른 응답 시간 + 적은 대기 시간.<br>
     // 웹 브라우저, 문서 편집기, 게임 등
  3. **Real-time System**: (실시간 시스템) 기한(deadline) 맞추는 것이 주목적. 속도와 정확성 중시.<br>
     // 항공기 제어 시스템, 의료 기기, 자동차 제어 시스템 등

각 유형 별로 다양한 알고리즘과 규칙으로 구성된 스케줄링 정책들이 있음.

## 2. 스케줄링 방식

- 선점 (preemptive) :<br>
  - 프로세스가 CPU를 할당받아 실행 중일 때, 또 다른 높은 우선순위의 프로세스가 도착하면 실행 중인 프로세스를 중단하고 새로운 프로세스에게 CPU를 할당하는 방식.
  - 선점 스케줄링을 사용하는 시스템에서는 우선순위가 높은 프로세스가 먼저 실행될 수 있으며, 우선순위는 동적임.
  - OS가 CPU의 사용권을 선점할 수 있기 때문에, 사용중에 강제 회수 가능 = 처리시간 예측 어려움.
- 비선점 (nonpreemptive) :<br>
  - 프로세스가 CPU를 할당받아 실행 중일 때, 다른 프로세스가 도착하더라도 현재 실행 중인 프로세스를 중단시키지 않고 그대로 끝까지 실행하는 방식.
  - 일괄처리 시스템에서 주로 사용.
  - 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 = 처리시간 예측 용이.

## 3. 프로세스 상태 변화

![download (5)](https://user-images.githubusercontent.com/13609011/91695344-f2dfae80-eba8-11ea-9a9b-702192316170.jpeg)

---

**프로세스의 상태 전이**

- **승인 (Admitted)** : 프로세스 생성(New) 승인.

- **스케줄러 디스패치 (Scheduler Dispatch)** : 준비(Ready) 상태에 있는 프로세스 중 하나를 선택하여 실행(Running).

- **인터럽트 (Interrupt)** : 예외, 입출력, 이벤트 등이 발생하여 현재 실행(Running) 중인 프로세스를 준비(Ready) 상태로 바꾸고, 해당 작업 먼저 처리.

- **입출력 또는 이벤트 대기 (I/O or Event wait)** : 실행(Running) 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기(Waiting) 상태로 전환.

- **입출력 또는 이벤트 완료 (I/O or Event Completion)** : 입출력/이벤트가 끝난 프로세스를 준비(Ready) 상태로 전환.

## 4. 종류

- 비선점 스케줄링

  1. FCFS (First Come First Served)
     - 큐에 도착한 순서대로 CPU 할당
     - 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐
  2. **SJF (Shortest Job First)**
     - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
     - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리
  3. HRN (Hightest Response-ratio Next)
     - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)
     - 우선순위 = (대기시간 + 실행시간) / (실행시간)

- 선점 스케줄링

  1. **Priority Scheduling**
     - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
     - 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation 이 생길 수 있음
     - Aging 방법으로 Starvation 문제 해결 가능
  2. **Round Robin**
     - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 `Time Quantum` 만큼 CPU를 할달 받음
     - 할당 시간(`Time Quantum`)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
  3. **Multilevel-Queue (다단계 큐)**

     - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법
     - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용
     - 우선순위가 높은 큐는 작은 `Time Quantum` 할당. 우선순위가 낮은 큐는 큰 `Time Quantum` 할당.

  4. **Multilevel-Feedback-Queue (다단계 피드백 큐)**
     - 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고 자신의 `Time Quantum`을 다 채우지 못한 프로세스는 원래 큐에 남음
     - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
     - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌

▼ 각각의 시스템 환경에 따라 선호되는 스케줄링 정책을 나타낸 표

| 시스템 환경 | 선점(Preemptive)                                                | 비선점(Non-preemptive)           |
| ----------- | --------------------------------------------------------------- | -------------------------------- |
| 일괄처리    | Round Robin                                                     | FCFS / SJF / Priority Scheduling |
| 대화형      | Round Robin / Priority Scheduling / Multilevel Queue Scheduling | X                                |
| 실시간      | Earliest Deadline First (EDF)                                   | X                                |

각각의 시스템에서 어떤 스케줄링 정책이 사용되는지는 그 시스템의 특성과 요구사항에 따라 다름.
이는 일반적인 경향성을 보여주는 것이며, 실제 상황에 따라 다양하게 선택될 여지가 있음.

## 5. 평가 척도

1. Response Time
   - 작업이 처음 실행되기까지 걸린 시간
2. Turnaround Time
   - 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간
