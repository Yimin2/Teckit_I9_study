# CPU Scheduling

## 1. 정의

: 여러 프로세스가 CPU를 사용하기 위해 경쟁할 때 어떤 프로세스가 CPU를 할당받을지를 결정하는 작업.
운영체제는 CPU 스케줄링 알고리즘을 통해 프로세스를 효율적으로 관리하고, 시스템의 성능을 최적화하기 위해 다양한 방식으로 CPU를 할당함.

- 목표 : 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓

\*_기아현상(Starvation): 낮은 우선순위를 가진 프로세스가 계속해서 CPU 자원을 할당받지 못하고 오래 대기해야 하는 현상_

- 시스템 환경 유형
  1. **Batch System**: (일괄처리 시스템) 가능하면 많은 일을 수행하는 것이 주목적. 처리량(throughout) 중시.<br>
     // 대규모 데이터 처리, 과학 및 공학 계산, 대량의 업무 처리 등
  2. **Interactive System**: (대화형 시스템) 사용자 경험 중시. 빠른 응답 시간 + 적은 대기 시간.<br>
     // 웹 브라우저, 문서 편집기, 게임 등
  3. **Real-time System**: (실시간 시스템) 기한(deadline) 맞추는 것이 주목적. 속도와 정확성 중시.<br>
     // 항공기 제어 시스템, 의료 기기, 자동차 제어 시스템 등

각 유형 별로 다양한 알고리즘과 규칙으로 구성된 스케줄링 정책들이 있음.

## 2. 스케줄링 방식

- 선점 (preemptive) :<br>
  - 프로세스가 CPU를 할당받아 실행 중일 때, 또 다른 높은 우선순위의 프로세스가 도착하면 실행 중인 프로세스를 중단하고 새로운 프로세스에게 CPU를 할당하는 방식.
  - 선점 스케줄링을 사용하는 시스템에서는 우선순위가 높은 프로세스가 먼저 실행될 수 있으며, 우선순위는 동적임.
  - OS가 CPU의 사용권을 선점할 수 있기 때문에, 사용중에 강제 회수 가능 = 처리시간 예측 어려움.
- 비선점 (nonpreemptive) :<br>
  - 프로세스가 CPU를 할당받아 실행 중일 때, 다른 프로세스가 도착하더라도 현재 실행 중인 프로세스를 중단시키지 않고 그대로 끝까지 실행하는 방식.
  - 일괄처리 시스템에서 주로 사용.
  - 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 = 처리시간 예측 용이.

## 3. 프로세스 상태 변화

![download (5)](https://user-images.githubusercontent.com/13609011/91695344-f2dfae80-eba8-11ea-9a9b-702192316170.jpeg)

---

**프로세스의 상태 전이**

- **승인 (Admitted)** : 프로세스 생성(New) 승인.

- **스케줄러 디스패치 (Scheduler Dispatch)** : 준비(Ready) 상태에 있는 프로세스 중 하나를 선택하여 실행(Running).

- **인터럽트 (Interrupt)** : 예외, 입출력, 이벤트 등이 발생하여 현재 실행(Running) 중인 프로세스를 준비(Ready) 상태로 바꾸고, 해당 작업 먼저 처리.

- **입출력 또는 이벤트 대기 (I/O or Event wait)** : 실행(Running) 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기(Waiting) 상태로 전환.

- **입출력 또는 이벤트 완료 (I/O or Event Completion)** : 입출력/이벤트가 끝난 프로세스를 준비(Ready) 상태로 전환.

## 4. 종류

- 비선점 스케줄링

  1. FCFS (First Come First Served)
     - 큐에 도착한 순서대로 CPU 할당
     - 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐
  2. **SJF (Shortest Job First)**
     - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
     - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리
  3. HRN (Hightest Response-ratio Next)
     - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)
     - 우선순위 = (대기시간 + 실행시간) / (실행시간)

- 선점 스케줄링

  1. **Priority Scheduling**
     - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
     - 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation 이 생길 수 있음
     - Aging 방법으로 Starvation 문제 해결 가능
  2. **Round Robin**
     - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 `Time Quantum` 만큼 CPU를 할당 받음
     - 할당 시간(`Time Quantum`)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
  3. **Multilevel-Queue (다단계 큐)**

     - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법
     - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용
     - 우선순위가 높은 큐는 작은 `Time Quantum` 할당. 우선순위가 낮은 큐는 큰 `Time Quantum` 할당.

  4. **Multilevel-Feedback-Queue (다단계 피드백 큐)**
     - 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고 자신의 `Time Quantum`을 다 채우지 못한 프로세스는 원래 큐에 남음
     - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
     - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turn-around 평균 시간을 줄여줌

▼ 각각의 시스템 환경에 따라 선호되는 스케줄링 정책을 나타낸 표

| 시스템 환경 | 선점(Preemptive)                                     | 비선점(Non-preemptive)           |
| ----------- | ---------------------------------------------------- | -------------------------------- |
| 일괄처리    | Round Robin                                          | FCFS / SJF / Priority Scheduling |
| 대화형      | Round Robin / Priority Scheduling / Multilevel Queue | X                                |
| 실시간      | Earliest Deadline First (EDF)                        | X                                |

각각의 시스템에서 어떤 스케줄링 정책이 사용되는지는 그 시스템의 특성과 요구사항에 따라 다름.
이는 일반적인 경향성을 보여주는 것이며, 실제 상황에 따라 다양하게 선택될 여지가 있음.

## 5. 평가 척도

1. Response Time
   - 작업이 처음 실행되기까지 걸린 시간
2. Turnaround Time
   - 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간

## QnA (feat. chatGPT)

Q. 비선점 스케줄링은 데드락을 피할 수 있는가?<br>
A. 아니오.

데드락은 [둘 이상의 스레드가 다른 스레드가 점유하고 있는 자원을 사용하려고 무한 대기](https://github.com/harriet221/Teckit_I9_study/blob/main/week02_11.02-11.08/week02_%EA%B8%88%EC%A2%85%EC%9D%80_Deadlock.md#deadlock)하고 있는 상태. 스케줄링 방식이 선점이냐 비선점이냐는 데드락 발생 여부와 직접적으로 연관되는 것은 아니며, 데드락의 발생 여부는 프로세스들 간의 자원 요청 및 할당 관리에 의해 결정된다.

자원의 비선점 할당의 경우, 자원이 한 번 할당되면 해당 자원을 강제로 뺏을 수 없기 때문에, 데드락이 발생할 가능성이 오히려 높아진다. 여러 프로세스가 필요한 자원을 갖고 있고, 서로가 서로의 자원을 뺏지 못하는 상황이 만들어지기 때문이다.

또한 프로세스가 이미 어떤 자원을 보유한 상태에서 다른 자원을 기다리는 자원 대기 상황의 경우에도, 해당 프로세스가 작업을 끝낼 때까지 기다려야 하기 때문에 데드락이 발생할 수 있다.

데드락을 피하기 위해서는 자원 할당 그래프를 통한 데드락 검출과 예방 기법을 사용해야 한다. 운영체제는 이러한 데드락 관리 기법과 지정된 스케줄링 방식을 적절히 조합하여 시스템이 안전하게 운영될 수 있도록 한다.
