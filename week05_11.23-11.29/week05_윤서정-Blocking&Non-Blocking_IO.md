# Blocking I/O & Non-Blocking I/O

## 1. 정의

일반적으로 I/O 작업은 데이터를 읽거나 쓰는 동안 해당 작업이 완료될 때까지 기다리는 블록킹(Blocking) 방식을 사용.

반면, Non-Blocking I/O는 입출력 작업을 수행할 때, 해당 작업이 완료될 때까지 대기하지 않고 즉시 결과를 반환하는 방식. 프로그램이 I/O 작업을 수행하는 동안 다른 작업을 계속 수행할 수 있게 해주는 일종의 비동기적인 방식. Blocking I/O의 단점을 극복하고 성능을 향상시키기 위해 도입.

## 2. Blocking I/O - 특징과 단점

기본적으로, 입출력 작업은 커널을 통해서만 수행 가능<br>
= Process, Thread는 커널에게 입출력 작업을 요청해야 함.

Blocking I/O 작업:

1. Process(Thread)가 커널에게 I/O를 요청하는 함수 호출

2. 커널이 작업을 완료하면 작업 결과를 반환 받음

→ I/O 작업이 진행되는 동안 User Process(Thread) 는 자신의 작업을 중단한 채 대기 = 자원 낭비가 심함 (I/O 작업은 CPU 자원을 거의 쓰지 않으므로)

특히, 여러 Client 가 접속하는 서버를 Blocking 방식으로 구현하는 경우,<br>
I/O 진행하는 작업을 중지 -> 다른 Client가 진행중인 작업을 중지할 수 없으므로, client 별로 별도의 Thread 생성 -> 다수의 Threads로 컨텍스트 스위칭 횟수가 증가<br>
= 매우 비효율적인 동작 방식

## 3. Non-Blocking I/O - 특징과 극복

: 입출력 작업이 진행되는 동안 User Process의 작업을 중단하지 않음.

Non-Blocking I/O 작업:

1. User Process가 recvfrom 함수 호출 (커널에게 해당 소켓으로부터 데이터를 받고 싶다고 요청)

2. 커널은 이 요청에 대해서, 곧바로 recvBuffer를 채워서 보내지 못하므로, "EWOULDBLOCK"을 반환

   이때, Blocking 방식과 달리, User Process는 다른 작업을 진행할 수 있음.

3. recvBuffer에 user가 받을 수 있는 데이터가 있는 경우, Buffer로부터 데이터를 복사하여 받아옴

   이때, recvBuffer는 커널이 가지고 있는 메모리에 적재되어 있으므로, 메모리 간 복사로 인해, I/O보다 훨씬 빠른 속도로 데이터를 받아올 수 있음.

4. recvfrom 함수는 빠른 속도로 데이터를 복사한 후, 복사한 데이터의 길이와 함께 반환

## 4. 정리

Non-Blocking I/O는 주로 네트워크 프로그래밍, 파일 시스템 접근, 이벤트 기반의 프로그래밍 환경 등에서 활용됨.<br>
ex/ 비동기 소켓 프로그래밍에서 클라이언트는 여러 소켓을 동시에 모니터하고, 데이터를 즉시 전송하거나 받아들이는 등의 작업 수행

그러나 여전히 Blocking I/O는 많은 상황에서 사용 중. 특히, 간단하고 직관적이며 사용하기 쉬운 특성으로 인해 여전히 많은 애플리케이션에서 활용되고 있음.<br>
ex/ 대부분의 동기화된 파일 입출력, 간단한 네트워크 통신, 터미널 입력 등의 상황에서 효과적
