# 객체지향 프로그래밍(Object Oriented Programming)

모든 데이터를 객체(object)로 취급하고, 객체가 처리 요청을 받았을 때 객체 내부에 있는 기능을 사용해 처리하는 프로그래밍 방법이다.

모든 객체가 내부의 자료형(field)과 함수(method)로 구성된 프로그래밍 구조를 의미한다.

C++, Java, Python 등이 대표적인 객체지향 언어이다.

## 장점

- 코드의 재사용이 가능하여 유지보수에 좋다.
- 분석과 설계의 전환이 쉽다.

## 단점

- 처리 속도가 상대적으로 느리다.
- 설계에 많은 시간이 소요된다.

## 특징

### 캡슐화(Encapsulation)

- 데이터의 구조와 역할, 기능을 하나의 캡슐 형태로 묶는 개념이다.
- 객체들 간의 의존도를(결합도) 낮춰 한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화한다.
- 클래스 내부에서만 데이터에 접근할 수 있도록 정보를 은닉하고, 외부에 영향을 받지 않고 객체 내부 구현을 변경할 수 있도록 함으로써 유지보수성을 높인다.

### 추상화(Abstraction)

- 데이터나 프로세스 등을 특성에 따라 따로 묶어서 정의하는 과정이다.
- 목적에 불필요한 부분을 제거하고 객체들의 공통적인 특징이나 특정한 성질만을 정의함으로써 코드를 단순화하고 프로그램의 유연성을 향상시킨다.

### 상속(Inheritance)

- 하나의 자식 클래스가 상위에 있는 부모 클래스의 속성과 동작을 물려받는 개념이다.
- 기존 클래스를 확장하거나 변경하지 않고도 새 클래스를 쉽게 정의할 수 있어 코드 재사용성이 높아지고, 클래스 간 계층 관계를 구조적으로 형성할 수 있다.

### 다형성(Polymorphism)

- 하나의 변수나 함수가 상황에 따라 다른 의미로 해석되어 동작할 수 있게 하는 성질이다.
- 동일한 인터페이스를 쓰면서도 객체의 타입에 따라 여러 다른 기능을 제공하게 함으로써 객체 간의 상호작용을 쉽게 구현하고 코드의 유연성을 높이는 역할을 한다.

## 설계 원칙 - SOLID

### SRP(Single Responsibility) - 단일 책임 원칙

- 클래스는 단 하나의 책임(담당 기능)만 가진다.
- 즉, 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는 데 집중되도록 설계해야 한다.
- 만일 하나의 클래스에 책임이 여러 개 있다면 기능 변경이 일어났을 때 수정해야 하는 코드가 많아진다.

### OCP(Open Closed Principle) - 개방 폐쇄 원칙

- 확장에는 열려있어야 하며, 수정에는 닫혀있어야 한다.
- 새로운 변경사항이 발생했을 때 유연하게 코드를 추가하여 쉽게 기능을 확장할 수 있어야 하지만, 객체를 직접적으로 수정하는 것은 제한한다.
- 추상 클래스와 상속을 통한 관계 구축을 권장하는 것이다.

### LSP(Liskov Substitution Principle) - 리스코프 치환 원칙

- 다형성의 원리를 이용하기 위한 원칙이다.
- 상위 클래스 타입으로 객체를 선언하고 하위 클래스의 인스턴스를 받았을 때, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것을 의미한다.

### ISP(Interface Segregation Principle) - 인터페이스 분리 원칙

- 인터페이스를 각 사용에 맞게 잘 분리해야 하며, 인터페이스의 단일 책임을 강조하는 것이다.
- 각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.
- 인터페이스는 자유롭게 다중 상속이 가능하므로, 최대한 분리해서 각 클래스의 용도에 맞게 구현하는 것이다.

### DIP(Dependency Inversion Principle) - 의존 역전 원칙

- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다.
- 어떤 클래스를 참조해서 사용해야 하는 경우에, 그 클래스를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스, 인터페이스)를 참조하는 원칙이다.
- 의존 관계를 맺을 때 변화하기 쉽거나 자주 변화하는 것보다 변화하기 어렵거나 변화가 없는 것에 의존하는 게 좋다.
- 각 클래스 간의 결합도를 낮추는 것이다.

---

> 참고 자료
</br>[Velog | Uné.log - 절차지향 & 객체지향 & 함수형 프로그래밍 ?](https://velog.io/@majaeh43/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D#-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
</br>[Inflearn | [INFCON Tech Series #3] 한눈에 보는 객체지향 프로그래밍 & 함수형 프로그래밍](https://www.inflearn.com/pages/infcon-2023-tech-oopfp)
</br>[Tistory | Inpa Dev 👨‍💻 - 💠 객체 지향 설계의 5가지 원칙 - S.O.L.I.D](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID)
</br>[Github | gyoogle/tech-interview-for-developer/Computer Science/Software Engineering/Object-Oriented Programming.md](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Software%20Engineering/Object-Oriented%20Programming.md)
